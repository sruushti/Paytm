/******/ var Queue=(function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/__build__/";
/******/
/******/ 	// Load entry module and return exports

/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Queue = (function () {
		function Queue() {
			_classCallCheck(this, Queue);
	
			this.queue = [];
			this._queue = [];
			this.type = 'LIFO';
		}
	
		_createClass(Queue, [{
			key: 'Queue',
			value: function Queue(type) {
				this.type = type == 'LOOP' ? 'LOOP' : 'LIFO';
			}
		}, {
			key: 'put',
			value: function put(work) {
				this.type == 'LOOP' ? (this.queue.push(work), this._queue.push(work)) : this.queue.push(work);
			}
		}, {
			key: 'get',
			value: function get() {
				if (this.queue.length) {
					return this.queue.shift();
				} else {
					if (this._queue.length) {
						this.queue = this._queue;
					}
					return false;
				}
			}
		}]);
	
		return Queue;
	})();
	
	module.exports = new Queue();

/***/ }
/******/ ]);


/******/ var Store=(function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/__build__/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var store = (function () {
		function store() {
			_classCallCheck(this, store);
	
			this.store = {};
		}
	
		_createClass(store, [{
			key: "get",
			value: function get(key) {
				return this.store[key];
			}
		}, {
			key: "set",
			value: function set(key, value) {
				key && value && (this.store[key] = value);
				return key;
			}
		}, {
			key: "del",
			value: function del(key) {
				if (this.store[key]) {
					delete this.store[key];
					return key;
				} else {
					return false;
				}
			}
		}]);
	
		return store;
	})();
	
	module.exports = new store();

/***/ }
/******/ ]);

/******/ var Distributed=(function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/__build__/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var distributed = (function () {
		function distributed() {
			_classCallCheck(this, distributed);
	
			this.store = {};
		}
	
		_createClass(distributed, [{
			key: 'findIndex',
			value: function findIndex(store, type, callback) {
				var index = -1;
				store.forEach(function (e, i) {
					if (e && e['type'] === type || e.callback === callback) {
						return index = i;
					}
				});
				return index;
			}
		}, {
			key: 'sub',
			value: function sub(type, callback) {
				if (typeof type == 'string' && typeof callback == 'function') {
					if (!this.store[type] || !Array.isArray(this.store[type])) {
						this.store[type] = [{ type: type, callback: callback }];
					} else if (this.findIndex(this.store[type], type, callback)) {
						this.store[type].push({ type: type, callback: callback });
					}
				}
			}
		}, {
			key: 'pub',
			value: function pub(type) {
				if (typeof type == 'string') {
					if (this.store[type] && Array.isArray(this.store[type])) {
						this.store[type].forEach(function (e, i) {
							e.callback.call(e.context, type);
						});
					}
				}
			}
		}, {
			key: 'unsub',
			value: function unsub(type, callback) {
				if (typeof type == 'string') {
					if (this.store[type] && Array.isArray(this.store[type])) {
						var i = this.findIndex(this.store[type], type, callback);
						i >= 0 ? this.store[type].splice(i, 1) : '';
					}
				}
			}
		}]);
	
		return distributed;
	})();
	
	module.exports = new distributed();

/***/ }
/******/ ]);

/******/ var flow=(function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/__build__/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	//import Queue from './lib/queue';
	//import Distributed from './lib/distributed';
	//import Store from './lib/store';
	
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Flow = (function () {
		function Flow() {
			_classCallCheck(this, Flow);
	
			this.version = '1.0.3';
			this.actionTypes = {};
			this.storeQueue = [];
			Queue.Queue('LOOP');
		}
	
		_createClass(Flow, [{
			key: 'createActions',
			value: function createActions(actionCreators) {
				var name = undefined;var creator = undefined;var actionsId = (this.id++).toString(32);
				var self = this;
				var actions = {};
	
				for (name in actionCreators) {
					creator = actionCreators[name];
					actions[name] = (function (creator, actionsId) {
						return function () {
							for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
								args[_key] = arguments[_key];
							}
	
							self.__dispatch__(actionsId, function () {
								return creator.apply(null, Array.prototype.slice.call(args));
							});
						};
					})(creator, actionsId);
				}
				return actions;
			}
		}, {
			key: 'createStore',
			value: function createStore(callbacks) {
				if (!callbacks) {
					throw new Error('callbacks不能为空');
				}
				var proxyMethon = {};
				proxyMethon.get = Store.get.bind(Store);
				proxyMethon.set = Store.set.bind(Store);
				proxyMethon.sub = Distributed.sub.bind(Distributed);
				proxyMethon.unsub = Distributed.unsub.bind(Distributed);
				this.storeQueue.push({
					store: Store,
					callbacks: callbacks
				});
				return proxyMethon;
			}
		}, {
			key: 'combineFlow',
			value: function combineFlow(middleware) {
				typeof middleware === 'function' && Queue.put(middleware);
			}
		}, {
			key: '__callback__',
			value: function __callback__(bear) {
				this.storeQueue.forEach(function (item) {
					var callback = item.callbacks[bear.type],
					    result = undefined,
					    changeKey = undefined;
					if (typeof callback === 'function') {
						result = callback(item.store, bear);
						if (result !== undefined) {
							Distributed.pub(result);
						}
					}
				});
			}
		}, {
			key: '__dispatch__',
			value: function __dispatch__(actionsId, action) {
				var _this = this;
	
				var self = this,
				    bear = action(),
				    actionTypes = this.actionTypes,
				    actionType = bear.type,
				    lastId = undefined;
				if (!actionType) throw new Error('action指令不存在 \n' + JSON.stringify(payload, null, 2));
				lastId = actionTypes[actionType];
				if (!lastId) {
					actionTypes[actionType] = actionsId;
				} else if (lastId !== actionsId) {
					throw new Error('action类型 "' + actionType + '" 重复');
				}
				var cb = function cb(bear) {
					var result = Queue.get();
					;result && result(bear,Store.store[bear.type],cb.bind(_this,bear));
					!result && _this.__callback__(bear);
				};
				cb(bear);
			}
		}]);
	
		return Flow;
	})();
	
	var flow = new Flow();
	flow.combineFlow(function (data, store, next) {
		next();
	});
	
	module.exports = { combineFlow: flow.combineFlow.bind(flow), createActions: flow.createActions.bind(flow), createStore: flow.createStore.bind(flow) };

/***/ }
/******/ ]);
exports.combineFlow=flow.combineFlow.bind(flow);
	exports.createActions=flow.createActions.bind(flow);
	exports.createStore=flow.createStore.bind(flow);